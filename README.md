相较于repoForCPUDeisn，重写了第一阶段代码，并在重写的基础上完成了第2，3阶段。
thirdcode.txt即第三阶段的指令。
开始进行流水线部分的设计，拆分步骤如下：
1. 参考IR.v，添加四个流水线寄存器.v文件，根据自己对控制信号的定义，完成I/O的定义。
2. 根据寄存器定义，进行实体化。
3. 修改其他部分组件的实体化，使它们支持流水线。
4. 继续回放学习，获得更多关于阻塞与旁路，解决冒险的指导，完成流水线设计。

更新日志：
4-15 完成1。
4-16 
    修正：
	交换了IF_ID.V,ID_EX.V的定义，及文件名
	修正了EX_MEM级reg_rd_out的位定义。
    在ID_EX中补充了EXT_IN及EXT_OUT。
    修改了EX_MEM中控制信号定义MEM2R系列。
    补充：
    在MIPS中添加了各级寄存器的输出定义，对于连续同传的值，根据本级的先一级命名，以做区分。比如IF_ID寄存器的PC_PLUS4_OUT_IF。
    利用补充的EXT_OUT及来自ID/EX级的PC_PLUS4_OUT_ID，实例化了EX/MEM级的位移量拓展后的PC地址，写法非常麻烦，后续验证或许可以修订为：
        PC_PLUS4_OUT_ID+(EXT_OUT<<2)
    MIPS中添加了各级寄存器的实体化，对于连续同传的值根据上述规则进行了区分。

    待完成：
    PCWR信号的决定需要重写，完全遵照多选器的格式，否则会导致各级信号的不区分。
    整个PC部分或许都需要重写，PC的决定应该在回传阶段。
    
4-17
    摸了。

4-18
计划：
    首先完成Mips中原先模块的实体化。
    思考是什么驱动了流水线的运行。可以参考已有代码。
    完成转发部分。
    解决冒险。
更新日志：
    决定暂时不支持J系列指令。
    我猜测shamt字段用于完成移位指令，其必然来源于ID/EX级.
    之前，即使是第三阶段，我仍然没有支持DMREAD信号，我应该在流水线部分的支持完成后支持它，这个应该在后续向老师指出。
    MEM/WB级无需存储器访问地址，将它修改为了ALU_C的保留。
    思路如下：
    1. 
首先，在rst信号传来时，PC被赋予初始值0000-3000
从ir中取出对应指令instr。
将PC+4及Instr写入IF/ID寄存器。
本级结束。

	2. 
instr产生了两个读寄存器rs,rt,来自25-21，20-16
//我立即产生了驱动流水线的想法，要使得各级部件流水地运行，那么上一级的clk信号必将引发下一级的clk信号，可这和之前的好像没区别…
根据两个寄存器号，就取出了两个数RD1和RD2。
可见IF/ID级应该传出两个寄存器的结果，也就是instr的一部分。
同级，访问EXT单元，传入IF/ID级指令的低16位，返回经过拓展的IMM32，应该要传入到ID/EX级。
//EXT要求EXTOP字段，否则不工作。CTRL单元在本级，可以直接传给EXT模块。
本级将根据instr的op和funct访问CTRL，同理，Instr应该来源于IF级寄存器。
产生的控制信号应该传给ID/EX级。
本级结束。（IF/ID级）
下一级应该传入PC+4,INSTR,RD1,RD2控制信号，符号拓展。

	3. 
ALU：
ALUSRC控制参与ALU运算的第二个数来源。它来源于ID/EX寄存器。决定是IMM32还是RD2，同理都来源于ID/EX寄存器。
还有shamt字段，同理。
ALU输出ALU_C和ZERO，写入EX/MEM。
我早些时候已经在MIPS里的按照本级要求，支持了branch决定的PC转移，并且将新的PC传给了下一级EX/MEM，故无需考虑。
本级结束。
下一级应该从本级获得转移PC，ALU_C，ZERO，及剩余的控制信号，instr和可能的PC+4.

	4. 
DM
DM根据ALU_C的11-2位决定访问地址，从前一个寄存器获得写信号，写寄存器，完成写操作，将读出数字dm_dout传给MEM/WB级。
本级回传上一级计算出的NPC，及PCWR。
仅支持beq及bne，PCWR=01情况，可用。
此时PC接收EX/MEM级传回的NPC_OUT

	5. 
写回寄存器写信号。
根据MEM2R，决定写回alu计算结果，或者存储器读出结果，作为寄存器写数据。
在IF/ID级，根据CTRL产生的控制信号，加上IF/ID级的instr，决定了写回寄存器编号，将写回寄存器编号连续传给MEM/WB级寄存器，将结果写回。


实体化完成。

开始实现转发/旁路，解决冒险。

